<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>火柴人羽毛球</title>
  <style>
    :root{--bg:#0f1724;--accent:#10b981;--muted:#9aa4b2;}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#071024);color:#e6eef8;font-family:Inter,Segoe UI,Helvetica,Arial,sans-serif;overflow:hidden;user-select:none;}
    
    /* 容器设为相对定位，方便内部 UI 绝对定位 */
    .wrap{width:100%; height:100%; position:relative; display:flex; justify-content:center; align-items:center; background:#000;}
    
    /* 游戏画布：最大化显示 */
    #gameCanvas{display:block; border-radius:4px; box-shadow:0 0 50px rgba(0,0,0,0.8); outline:none;}

    /* === 新版悬浮 UI 层 === */
    #gameUI {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none; /* 让鼠标点击穿透 UI 层，直达 Canvas */
        display: flex; flex-direction: column; justify-content: space-between;
        padding: 20px; box-sizing: border-box;
    }

    /* 调整 top-bar 布局，使其居中对齐 */
    .top-bar { 
        display: flex; justify-content: center; align-items: center; gap: 30px; width: 100%; pointer-events: none; 
    }

    /* 能量条容器 */
    .energy-box { display: flex; flex-direction: column; gap: 4px; width: 150px; }
    .e-label { font-size: 12px; font-weight: bold; text-shadow: 0 1px 2px #000; }
    .e-bar-bg { 
        width: 100%; height: 8px; background: rgba(0,0,0,0.5); 
        border: 1px solid rgba(255,255,255,0.3); border-radius: 4px; overflow: hidden; 
    }
    .e-bar-fill { 
        width: 0%; height: 100%; transition: width 0.1s linear; 
        box-shadow: 0 0 10px currentColor; /* 发光效果 */
    }

    /* 能量满时的动画类 (JS添加) */
    .energy-full { animation: pulseBar 0.5s infinite alternate; filter: brightness(1.3); }
    @keyframes pulseBar { from { opacity: 0.8; } to { opacity: 1.0; box-shadow: 0 0 15px currentColor; } }

    /* 积分板样式微调 */
    /* === 新版记分板样式 === */
    .score-board {
        display: flex; 
        align-items: center; 
        justify-content: center;
        gap: 15px; 
        
        /* 盒子外观 */
        background: rgba(0, 0, 0, 0.6); /* 深黑半透明背景 */
        border: 2px solid rgba(255, 255, 255, 0.2); /* 细边框 */
        border-radius: 8px; /* 圆角 */
        padding: 5px 25px;
        
        /* 字体设置 */
        font-family: 'Courier New', Courier, monospace; /* 等宽字体，更有电子感 */
        font-size: 36px; 
        font-weight: 900;
        color: #fff;
        text-shadow: 0 0 10px rgba(255,255,255,0.5); /* 淡淡的荧光 */
        
        pointer-events: auto;
        backdrop-filter: blur(8px);
        box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        min-width: 140px; /* 保证宽度稳定，不跳动 */
    }

    /* 分数颜色微调 */
    #p1Stat { color: #ffe5b4; }
    #p2Stat { color: #cde7ff; }
    .divider { color: #666; font-size: 28px; position: relative; top: -2px; }
        
    .game-title {
        font-size: 14px; color: rgba(255,255,255,0.5); font-weight: 600;
        text-transform: uppercase; letter-spacing: 1px;
        position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
    }

    /* 按钮样式：开启 pointer-events 以便点击 */
    button { pointer-events: auto; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.2); padding:8px 16px; border-radius:8px; color:#fff; font-weight:600; cursor:pointer; transition:0.2s; font-size:14px; backdrop-filter:blur(4px); }
    button:hover { background:rgba(255,255,255,0.2); transform:scale(1.05); }
    button:active { transform:scale(0.95); }

    /* 底部提示 */
    .bottom-tips {
        text-align: center; font-size: 12px; color: rgba(255,255,255,0.4); 
        margin-bottom: 5px; text-shadow: 0 1px 2px #000;
    }

    /* 菜单与遮罩 */
    #overlay, #charSelectScreen {
      position: absolute; top:0; left:0; width:100%; height:100%;
      background: rgba(0,0,0,0.9); display:flex; justify-content:center; align-items:center; flex-direction:column; z-index:20;
      backdrop-filter: blur(10px); pointer-events: auto;
    }
    #overlay { display:none; }
    #charSelectScreen h2 { font-size: 32px; margin-bottom: 20px; color: #fff; text-transform: uppercase; letter-spacing: 2px; }
    
    .mode-switch, .difficulty-switch { display: flex; gap: 8px; margin-bottom: 20px; }
    .mode-opt, .diff-opt { padding: 8px 16px; border: 1px solid rgba(255,255,255,0.2); border-radius: 20px; font-size: 14px; color: #aaa; cursor: pointer; transition: 0.2s; }
    .mode-opt.active, .diff-opt.active { background: #fff; color: #000; font-weight: bold; box-shadow: 0 0 10px rgba(255,255,255,0.3); }

    .selection-area { display: flex; gap: 40px; margin-bottom: 30px; flex-wrap:wrap; justify-content:center;}
    .player-col { display: flex; flex-direction: column; align-items: center; gap: 15px; }
    .col-title { font-size: 18px; font-weight: bold; color: #ccc; margin-bottom: 10px; }
    .char-grid { display: grid; grid-template-columns: 1fr; gap: 10px; }
    .char-card { background: rgba(255,255,255,0.05); border: 2px solid transparent; border-radius: 8px; padding: 10px; width: 140px; cursor: pointer; transition: 0.2s; display: flex; align-items: center; gap: 10px; }
    .char-card:hover { background: rgba(255,255,255,0.1); }
    .char-card.selected { border-color: var(--accent); background: rgba(16, 185, 129, 0.15); }
    .mini-icon { width: 30px; height: 30px; border-radius: 50%; flex-shrink:0; }
    .char-info { display: flex; flex-direction: column; text-align: left; }
    .c-name { font-weight: bold; font-size: 14px; color: #fff; }
    .c-desc { font-size: 11px; color: #aaa; }
    .p2-locked .char-card { display: none; }
    .p2-locked::after { content: "CPU (随机)"; color: #666; font-size: 20px; font-weight: bold; border: 2px dashed #444; border-radius: 12px; width: 140px; height: 220px; display: flex; align-items: center; justify-content: center; }

    #btnStartGame { padding: 15px 50px; font-size: 22px; background: var(--accent); color: #000; margin-top: 10px; box-shadow: 0 4px 15px rgba(16, 185, 129, 0.4); font-weight:900; }
    #msgBox { position:absolute; top: 150px; left:50%; transform:translateX(-50%); font-size: 32px; font-weight:900; color: #ff4444; text-shadow: 0 2px 8px rgba(0,0,0,0.8); pointer-events: none; opacity: 0; transition: opacity 0.3s, transform 0.2s; white-space: nowrap; z-index: 10; font-style: italic; }
  </style>
</head>
<body>

  <!-- 角色选择界面 -->
  <div id="charSelectScreen">
    <h2>比赛设置</h2>
    <div class="mode-switch">
        <div class="mode-opt active" id="optCpu" onclick="setSelectMode('cpu')">单人挑战</div>
        <div class="mode-opt" id="optPvp" onclick="setSelectMode('pvp')">双人对战</div>
    </div>
    <div class="difficulty-switch" id="diffSelect">
        <div class="diff-opt" onclick="setDifficulty('easy')">简单</div>
        <div class="diff-opt active" onclick="setDifficulty('normal')">一般</div>
        <div class="diff-opt" onclick="setDifficulty('hard')">困难</div>
        <div class="diff-opt" style="color:#ef4444" onclick="setDifficulty('hell')">疯狗</div>
    </div>
    <div class="selection-area">
        <div class="player-col">
            <div class="col-title" style="color:#ffe5b4">Player 1</div>
            <div class="char-grid" id="p1Grid"></div>
        </div>
        <div style="display:flex; align-items:center; font-size:30px; font-weight:900; color:#555; font-style:italic;">VS</div>
        <div class="player-col" id="p2Col">
            <div class="col-title" style="color:#cde7ff">Player 2</div>
            <div class="char-grid" id="p2Grid"></div>
        </div>
    </div>
    <button id="btnStartGame">开始比赛</button>
  </div>

  <!-- 胜利结算界面 -->
  <div id="overlay">
    <h2 id="winnerText" style="font-size:48px; color:#f59e0b; margin-bottom:20px;"></h2>
    <button onclick="location.reload()" style="font-size:18px; padding:12px 24px;">返回菜单</button>
  </div>

  <!-- 游戏主容器 -->
  <div class="wrap">
    <canvas id="gameCanvas" tabindex="0"></canvas>
    
    <!-- 悬浮 UI 层 (替代了原来的 header) -->
    <div id="gameUI">
        <!-- <div class="game-title">Stickman Badminton</div> -->
        
        <!-- 修改 top-bar 区域 -->
        <div class="top-bar">
            <!-- P1 能量条 -->
            <div class="energy-box p1-box">
                <div class="e-label" style="color:#ffe5b4">P1 能量</div>
                <div class="e-bar-bg"><div id="p1EBar" class="e-bar-fill" style="background:#ffe5b4"></div></div>
            </div>

            <!-- 记分板 (修改这里) -->
            <div class="score-board">
                <span id="p1Stat">0</span>
                <span class="divider">-</span>
                <span id="p2Stat">0</span>
            </div>

            <!-- P2 能量条 -->
            <div class="energy-box p2-box">
                <div class="e-label" style="color:#cde7ff">P2 能量</div>
                <div class="e-bar-bg"><div id="p2EBar" class="e-bar-fill" style="background:#cde7ff"></div></div>
            </div>
        </div>
        
        <div style="text-align:center; margin-top:5px;"><button id="btnReset">重置</button></div>
        
        <div id="msgBox">扣杀得分!</div>
        
    </div>
  </div>

<script>
const CHARACTERS = [
    { id: 'balanced', name: '均衡型', color: '#ffe5b4', speed: 1.5, jump: 6.5, charge: 0.04, smash: 1.0, hitRange: 75, maxPower: 1.0, doubleJump: false, desc: '手感稳健 觉醒' },
    { id: 'speed',    name: '极速型', color: '#60a5fa', speed: 2.5, jump: 7.0, charge: 0.06, smash: 0.9, hitRange: 70, maxPower: 0.9, doubleJump: false, desc: '速度快 飞行' },
    { id: 'power',    name: '力量型', color: '#ef4444', speed: 1.0, jump: 6.5, charge: 0.02, smash: 1.2, hitRange: 80, maxPower: 1.2, doubleJump: false, desc: '威力大 击退' },
    { id: 'ninja',    name: '忍者型',   color: '#10b981', speed: 1.25, jump: 6.0, charge: 0.05, smash: 1.0, hitRange: 75, maxPower: 1.0, doubleJump: true,  desc: '二段跳 忍术' }
];

const DIFFICULTY_SETTINGS = {
    easy:   { reaction: 30, error: 80, speedMult: 0.7, smashProb: 0.01, chargeSpeed: 0.8, intercept: false },
    normal: { reaction: 15, error: 40, speedMult: 1.0, smashProb: 0.15, chargeSpeed: 1.0, intercept: false },
    hard:   { reaction: 5,  error: 10, speedMult: 1.2, smashProb: 0.50, chargeSpeed: 1.5, intercept: true }, 
    hell:   { reaction: 0,  error: 0,  speedMult: 1.4, smashProb: 0.85, chargeSpeed: 3.0, intercept: true } 
};

let currentMode = 'cpu';
let selectedDifficulty = 'normal';
let p1Selected = 'balanced';
let p2Selected = 'balanced';

// DOM Elements
const scoreP = document.getElementById('p1Stat'); 
const scoreA = document.getElementById('p2Stat'); 
const winnerOverlay = document.getElementById('overlay'); 
const winnerText = document.getElementById('winnerText'); 
const msgBox = document.getElementById('msgBox');
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

function renderCharCards(containerId, isP1) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    CHARACTERS.forEach(char => {
        const div = document.createElement('div');
        div.className = `char-card ${isP1 ? (p1Selected===char.id?'selected':'') : (p2Selected===char.id?'selected':'')}`;
        div.innerHTML = `<div class="mini-icon" style="background:${char.color}"></div><div class="char-info"><span class="c-name">${char.name}</span><span class="c-desc">${char.desc}</span></div>`;
        div.onclick = () => { if(isP1) { p1Selected = char.id; updateGridSelection('p1Grid', p1Selected); } else { p2Selected = char.id; updateGridSelection('p2Grid', p2Selected); } };
        container.appendChild(div);
    });
}
function updateGridSelection(gridId, selectedId) {
    const grid = document.getElementById(gridId);
    Array.from(grid.children).forEach((card, idx) => {
        if(CHARACTERS[idx].id === selectedId) card.classList.add('selected'); else card.classList.remove('selected');
    });
}
function setSelectMode(mode) {
    currentMode = mode;
    document.getElementById('optCpu').className = mode==='cpu' ? 'mode-opt active' : 'mode-opt';
    document.getElementById('optPvp').className = mode==='pvp' ? 'mode-opt active' : 'mode-opt';
    const p2Col = document.getElementById('p2Col'); const diffSelect = document.getElementById('diffSelect');
    if(mode === 'cpu') { p2Col.classList.add('p2-locked'); diffSelect.style.opacity = '1'; diffSelect.style.pointerEvents = 'auto'; } 
    else { p2Col.classList.remove('p2-locked'); diffSelect.style.opacity = '0.3'; diffSelect.style.pointerEvents = 'none'; }
}
function setDifficulty(diff) {
    selectedDifficulty = diff;
    const opts = document.querySelectorAll('.diff-opt'); const keys = ['easy', 'normal', 'hard', 'hell'];
    opts.forEach((el, idx) => { if (keys[idx] === diff) el.classList.add('active'); else el.classList.remove('active'); });
}

renderCharCards('p1Grid', true); renderCharCards('p2Grid', false); setSelectMode('cpu'); setDifficulty('normal');

document.getElementById('btnStartGame').onclick = () => {
    document.getElementById('charSelectScreen').style.display = 'none';
    let p2FinalChar = p2Selected;
    if(currentMode === 'cpu') { const rand = CHARACTERS[Math.floor(Math.random() * CHARACTERS.length)]; p2FinalChar = rand.id; }
    initGameProps(p1Selected, p2FinalChar);
    gameMode = currentMode;
    startGame();
};

let W = 1200, H = 600; let dpr = Math.max(1, window.devicePixelRatio || 1);
const margin = 100; const MAX_SCORE = 11; const COURT_PADDING = 30; 
let gameMode = 'cpu'; let serving = 'player'; let lastHitter = 'player';
let running = false, paused = false, lastTime = 0; let gameOver = false;
let particles = [];
let worldGravity = 0.25; let airDrag = 0.996; 
let player = { x: margin, y: H/2, vx:0, vy:0, onGround:true, handX:0, handY:0, swingTimer:0, swingAnim:0, score:0, charging:false, chargeVal:0, speed:3.5, jumpPower:8, chargeRate:0.03, smashMult:1, hitRange:70, maxPower:1.0, doubleJump:false, jumpCount:0, color:'#fff', roleName:'' };
let player2 = { x: W-margin, y: H/2, vx:0, vy:0, onGround:true, handX:0, handY:0, swingTimer:0, swingAnim:0, score:0, charging:false, chargeVal:0, speed:3.5, jumpPower:8, chargeRate:0.03, smashMult:1, hitRange:70, maxPower:1.0, doubleJump:false, jumpCount:0, color:'#fff', roleName:'' };
let shuttle = { x: W/2, y: H/3, vx:0, vy:0, radius: 8, stuck:true, isSmash: false };
let baseSpeed = 3.5; let level = 1;

const AudioCtx = window.AudioContext || window.webkitAudioContext; const audioCtx = AudioCtx ? new AudioCtx() : null;
function beep(freq, time=0.1, type='sine', vol=0.1){
  if(!audioCtx) return; if(audioCtx.state === 'suspended') audioCtx.resume();
  try { const o=audioCtx.createOscillator();const g=audioCtx.createGain();o.type=type;o.frequency.setValueAtTime(freq,audioCtx.currentTime);if(type==='sawtooth')o.frequency.exponentialRampToValueAtTime(freq/2,audioCtx.currentTime+time);o.connect(g);g.connect(audioCtx.destination);g.gain.setValueAtTime(0.001,audioCtx.currentTime);g.gain.exponentialRampToValueAtTime(vol,audioCtx.currentTime+0.02);g.gain.exponentialRampToValueAtTime(0.001,audioCtx.currentTime+time);o.start();o.stop(audioCtx.currentTime+time+0.05); } catch(e){}
}
function playSmashSound(power) {
  if(!audioCtx) return; if(audioCtx.state === 'suspended') audioCtx.resume();
  try {
      const t = audioCtx.currentTime;
      const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
      osc.type = 'triangle'; osc.frequency.setValueAtTime(150 + power*100, t); osc.frequency.exponentialRampToValueAtTime(40, t + 0.15);
      gain.gain.setValueAtTime(0.5, t); gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
      osc.connect(gain); gain.connect(audioCtx.destination); osc.start(t); osc.stop(t + 0.2);
      const osc2 = audioCtx.createOscillator(); const gain2 = audioCtx.createGain();
      osc2.type = 'square'; osc2.frequency.setValueAtTime(800, t); osc2.frequency.exponentialRampToValueAtTime(100, t + 0.05);
      gain2.gain.setValueAtTime(0.3, t); gain2.gain.exponentialRampToValueAtTime(0.01, t + 0.05);
      osc2.connect(gain2); gain2.connect(audioCtx.destination); osc2.start(t); osc2.stop(t + 0.1);
  } catch(e){}
}
// 新增：大招开启音效 (高能聚气声)
function playSkillSound() {
  if(!audioCtx) return; if(audioCtx.state === 'suspended') audioCtx.resume();
  try {
      const t = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      
      // 频率快速爬升，模拟聚气/爆发
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(200, t);
      osc.frequency.exponentialRampToValueAtTime(800, t + 0.3);
      
      gain.gain.setValueAtTime(0.1, t);
      gain.gain.linearRampToValueAtTime(0.3, t + 0.2);
      gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
      
      osc.connect(gain); gain.connect(audioCtx.destination);
      osc.start(t); osc.stop(t + 0.5);
  } catch(e){}
}
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

function resize(){ 
  const maxW = Math.min(window.innerWidth - 20, 1600); 
  // 最大化高度，只留一点边距
  const availableH = window.innerHeight - 20; 
  const cssW = Math.max(300, maxW); 
  // 提高最大高度限制到 900
  const cssH = Math.min(900, Math.max(300, availableH)); 
  
  canvas.style.width = cssW + 'px'; canvas.style.height = cssH + 'px'; canvas.width = Math.round(cssW * dpr); canvas.height = Math.round(cssH * dpr); 
  ctx.setTransform(dpr,0,0,dpr,0,0); W = cssW; H = cssH; recalcPositions(); if(running) draw(); 
}
window.addEventListener('resize', resize); resize();

function updateUI(){ 
    // 只更新数字，保持纯净
    scoreP.innerText = player.score; 
    scoreA.innerText = player2.score; 
}
function showMsg(text) { msgBox.textContent = text; msgBox.style.opacity = 1; msgBox.style.transform = "translateX(-50%) scale(1.2)"; setTimeout(() => { msgBox.style.opacity = 0; msgBox.style.transform = "translateX(-50%) scale(1)"; }, 1000); }

function initGameProps(p1Id, p2Id) {
    const p1Data = CHARACTERS.find(c => c.id === p1Id);
    const p2Data = CHARACTERS.find(c => c.id === p2Id);

    const applyStats = (p, data) => { 
        // ... 原有的属性赋值 ...
        p.speed = data.speed; p.jumpPower = data.jump; p.chargeRate = data.charge; 
        p.smashMult = data.smash; p.hitRange = data.hitRange; p.color = data.color; 
        p.roleName = data.name; p.maxPower = data.maxPower; p.doubleJump = data.doubleJump; 
        p.jumpCount = 0; 
        p.hasHit = false; 
        
        // === 新增：技能系统属性 ===
        p.energy = 0;           // 当前能量 (0-100)
        p.maxEnergy = 100;
        p.skillActive = false;  // 技能是否激活中
        p.skillTimer = 0;       // 技能剩余时间
        p.baseStats = { ...data }; // 备份基础属性，用于技能结束后恢复
        p.id = data.id;         // 记录ID以便判断技能类型
        p.trails = []; 

        p.isGiant = false; 
        p.impactVx = 0; // 额外的击退速度
    };
    
    applyStats(player, CHARACTERS.find(c => c.id === p1Id)); 
    applyStats(player2, CHARACTERS.find(c => c.id === p2Id)); 

    // 修改 P1 颜色 (计分板、能量条、标签)
    const p1Color = p1Data.color;
    document.getElementById('p1Stat').style.color = p1Color;
    document.getElementById('p1EBar').style.backgroundColor = p1Color;
    document.querySelector('.p1-box .e-label').style.color = p1Color;

    // 修改 P2 颜色
    const p2Color = p2Data.color;
    document.getElementById('p2Stat').style.color = p2Color;
    document.getElementById('p2EBar').style.backgroundColor = p2Color;
    document.querySelector('.p2-box .e-label').style.color = p2Color;

    updateUI();
}

// === 按键控制 (瞬发 + 蓄力 分离版) ===
const keys = {};

// === 封装：瞬发击球处理函数 ===
function actionHit(p, power) {
    // 只有当不在挥拍冷却中时才允许击球
    if (p.swingTimer === 0) {
        
        // 如果正在蓄力中按下了瞬发键，优先瞬发，并取消蓄力状态
        p.charging = false;
        p.chargeVal = 0;

        // 如果是发球阶段，且轮到该玩家
        if (shuttle.stuck) {
            const isP1Serving = (serving === 'player' && p === player);
            const isP2Serving = (serving === 'player2' && p === player2);
            
            if (isP1Serving || isP2Serving) {
                p.swingAnim = 10;
                serve(isP1Serving ? 'player' : 'player2', power);
            }
        } 
        // 正常击球阶段
        else {
            triggerSwing(p, power);
        }
    }
}

// === 新版按键监听 (中击瞬发 + 蓄力 + 技能) ===
window.addEventListener('keydown', e => { 
    keys[e.code] = true; if(gameOver) return; 
    
    // ------ Player 1 操作 ------
    
    // [中击] 空格键: 瞬发 0.5 力度
        // [瞬发组合键] Space
    if(e.code === 'Space') {
        let hitPower = 0.5; // 默认中等力度
        
        // 判定组合键
        if (keys['KeyS']) {
            hitPower = 0.3; // S + Space = 轻击 (吊球)
        } else if (keys['KeyD']) {
            hitPower = 0.8; // D + Space = 重击 (扣杀/高远)
        }
        
        actionHit(player, hitPower);
    }

    // [蓄力] J键: 开始蓄力
    if(e.code === 'KeyJ'){ 
        if(!player.charging){ player.charging = true; player.chargeVal = 0; } 
    }

    // [技能] 左Shift键: 奥义
    if(e.code === 'ShiftLeft') activateSkill(player);

    // [移动] W键: 跳跃
    if(e.code === 'KeyW'){ 
        // === 新增：如果正在飞行，W键不触发跳跃，而是由 update 处理持续上升 ===
        if (player.skillActive && player.id === 'speed') return; 

        if(player.onGround) {
            player.vy = -player.jumpPower; player.onGround = false; player.jumpCount = 1;
        } else if (player.doubleJump && player.jumpCount < 2) {
            player.vy = -player.jumpPower * 0.9; player.jumpCount = 2;
            createHitParticles(player.x, player.y + 40, '#fff', 8);
        }
    }

    // ------ Player 2 操作 (PVP) ------
    if(gameMode === 'pvp') {
        // [瞬发组合键] Numpad Enter
        if(e.code === 'Enter' || e.code === 'NumpadEnter') {
            let hitPower = 0.5; // 默认
            
            // 判定组合键
            if (keys['ArrowDown']) {
                hitPower = 0.3; // 下 + Enter = 轻击
            } else if (keys['ArrowLeft']) {
                hitPower = 0.8; // 左 + Enter = 重击
            }
            
            actionHit(player2, hitPower);
        }

        // [蓄力] 小键盘 1
        if(e.code === 'Numpad1'){ 
            if(!player2.charging){ player2.charging = true; player2.chargeVal = 0; } 
        }

        // [技能] 小键盘 0
        if(e.code === 'Numpad0') activateSkill(player2);

        // [移动] Up: 跳跃
        if(e.code === 'ArrowUp'){ 
            if (player2.skillActive && player2.id === 'speed') return;
            
            if(player2.onGround) {
                player2.vy = -player2.jumpPower; player2.onGround = false; player2.jumpCount = 1;
            } else if (player2.doubleJump && player2.jumpCount < 2) {
                player2.vy = -player2.jumpPower * 0.9; player2.jumpCount = 2;
                createHitParticles(player2.x, player2.y + 40, '#fff', 8);
            }
        }
    } 
});

// === KeyUp 监听 (只处理 J 和 Numpad1 的蓄力释放) ===
window.addEventListener('keyup', e => { 
    keys[e.code] = false; 
    
    // P1 松开 J -> 释放蓄力
    if(e.code === 'KeyJ' && player.charging){ 
        player.charging = false; 
        if(shuttle.stuck && serving === 'player'){ 
            player.swingAnim = 10; 
            serve('player', player.chargeVal); 
        } else { 
            triggerSwing(player, player.chargeVal); 
        } 
        player.chargeVal = 0; 
    } 

    // P2 松开 Numpad1 -> 释放蓄力
    if(e.code === 'Numpad1' && player2.charging && gameMode === 'pvp'){ 
        player2.charging = false; 
        if(shuttle.stuck && serving === 'player2'){ 
            player2.swingAnim = 10; 
            serve('player2', player2.chargeVal); 
        } else { 
            triggerSwing(player2, player2.chargeVal); 
        } 
        player2.chargeVal = 0; 
    } 
});

canvas.addEventListener('mousedown', ()=>{ canvas.focus(); if(audioCtx && audioCtx.state==='suspended') audioCtx.resume(); });
document.getElementById('btnReset').onclick = ()=>{ if(!running) return; player.score=0; player2.score=0; level=1; resetRound(); updateUI(); canvas.focus(); };

function startGame(){ if(running) return; running = true; paused = false; lastTime = performance.now(); resetRound(); requestAnimationFrame(loop); }
function resetRound(){ serving='player'; lastHitter='player'; player.x = margin; player2.x = W - margin; player.y=player2.y=H/2; player.charging=false; player2.charging=false; player.vx=0; player2.vx=0; shuttle.stuck=true; shuttle.vx=shuttle.vy=0; shuttle.isSmash=false; particles = []; if(gameMode === 'cpu') resetAI(); recalcPositions(); }
function recalcPositions(){ player.x = clamp(player.x, 10, W/2 - 60); player2.x = clamp(player2.x, W/2 + 60, W - 10); if(shuttle.stuck){ if(serving === 'player') { shuttle.x = player.x + 40; shuttle.y = player.y - 70; } else { shuttle.x = player2.x - 40; shuttle.y = player2.y - 70; } } }

function serve(who='player', power=0.5){
  if(!shuttle.stuck) return; 
  serving = who; lastHitter = who; shuttle.stuck = false; shuttle.isSmash = false;
  const dir = who === 'player' ? 1 : -1; const pObj = who === 'player' ? player : player2; 
  let actualPower = Math.max(0.2, power); let powerCurve = 1.0 + actualPower * 1.0; 
  let speedX = (baseSpeed + level * 0.3) * powerCurve * pObj.maxPower; if (speedX > 25) speedX = 25; 
  let speedY = -7 - (actualPower * 7); 
  shuttle.x = dir===1 ? (player.x + 50) : (player2.x - 50); shuttle.y = dir===1 ? (player.y - 80) : (player2.y - 80);
  shuttle.vx = dir * speedX; shuttle.vy = speedY; 
  beep(400 + actualPower*200, 0.1, 'sine');
}

function pointScored(who, reason=""){ if(reason) showMsg(reason); if(who === 'player') player.score++; else player2.score++; beep(who==='player'?600:200, 0.4, 'square', 0.1); updateUI(); if(player.score >= MAX_SCORE || player2.score >= MAX_SCORE) { gameOver = true; winnerText.textContent = (player.score >= MAX_SCORE ? "玩家 1" : (gameMode==='cpu'?"电脑":"玩家 2")) + " 获胜!"; winnerOverlay.style.display = "flex"; return; } const total = player.score + player2.score; level = 1 + Math.floor(total / 5); serving = who; shuttle.stuck = true; shuttle.vx = shuttle.vy = 0; recalcPositions(); if(gameMode === 'cpu') resetAI(); }
// === 核心：技能释放逻辑 ===
function activateSkill(p) {
    if (p.energy < 100 || p.skillActive) return; // 能量不够或正在释放中

    p.skillActive = true;
    p.energy = 0;
    p.skillTimer = 600; // 持续 300 帧 (约5秒)
    
    playSkillSound(); 

    showMsg(`${p === player ? "P1" : "P2"} 开启奥义!`);
    createHitParticles(p.x, p.y, '#ffff00', 50); // 爆气特效

    // 根据角色类型应用 Buff
    if (p.id === 'balanced') {
        // 均衡型觉醒：全属性 * 1.4
        p.speed *= 1.4;
        p.jumpPower *= 1.2;
        p.maxPower *= 1.4;
        p.smashMult *= 1.3;
        p.hitRange *= 1.5; // 判定范围变大
    } 
    else if (p.id === 'ninja') {
        p.hitRange *= 2.2; 
        p.shadowClone = true;
        // 忍者的特殊逻辑主要在 update 函数中体现
    }
    else if (p.id === 'power') {
        // === 力量型：泰坦形态 ===
        p.isGiant = true;
        p.hitRange *= 1.8;  // 手变长了，范围变大
        p.maxPower *= 1.2;  // 力气变大
    }
}
// === 技能结束逻辑 ===
function deactivateSkill(p) {
    p.skillActive = false;
    // 恢复基础属性
    p.speed = p.baseStats.speed;
    p.jumpPower = p.baseStats.jump;
    p.maxPower = p.baseStats.maxPower;
    p.smashMult = p.baseStats.smash;
    p.hitRange = p.baseStats.hitRange;
    // 关闭忍者分身标记
    if (p.id === 'ninja') p.shadowClone = false;
    if (p.id === 'power') p.isGiant = false;
}
function triggerSwing(pObj, power) { pObj.swingTimer = 25; pObj.swingAnim = 10; pObj.lastPower = power; pObj.hasHit = false; }
function collideRacket(pObj){ return Math.hypot(shuttle.x - pObj.handX, shuttle.y - pObj.handY) < (shuttle.radius + pObj.hitRange); }

const AI_STATE = { IDLE: 0, MOVING: 1, PREPARING: 2, STRIKING: 3 };
let ai = {
  state: AI_STATE.IDLE, targetX: W - 150, baseX: W - 150, reactionTimer: 0, 
  predictedX: null, interceptY: null, willOut: false, smashIntent: false, 
  errorOffset: 0, serveTargetPower: 0, recalcTimer: 0, serveDelay: 0
};

function resetAI() {
  ai.state = AI_STATE.IDLE; ai.baseX = W * 0.75; ai.targetX = ai.baseX; ai.predictedX = null; ai.interceptY = null; ai.willOut = false; 
  ai.reactionTimer = 0; ai.errorOffset = 0; ai.recalcTimer = 0;
  ai.serveDelay = 30 + Math.random() * 40; 
  player2.charging = false; player2.chargeVal = 0;
}

function analyzeTrajectory(p2) {
  if (shuttle.vx <= 0 && !shuttle.stuck) return null;
  
  let timeSteps = 0;
  // 模拟变量
  let simX = shuttle.x, simY = shuttle.y, simVx = shuttle.vx, simVy = shuttle.vy;
  const groundY = H - 40; 
  
  let bestIntercept = null;
  let landingX = null;
  
  // 模拟未来 180 帧
  while (simY < groundY && timeSteps < 180) { 
      simVy += worldGravity * 0.8; 
      simVx *= 0.99; 
      simX += simVx; 
      simY += simVy; 
      timeSteps++;

      // === 新增：AI 预测中的反弹逻辑 ===
      // 天花板反弹
      if (simY < 0) {
          simY = 0;
          simVy = -simVy * 0.8; // 模拟能量损耗
      }
      // 右墙反弹 (AI身后的墙)
      if (simX > W) {
          simX = W;
          simVx = -simVx * 0.8;
      }
      // 左墙反弹 (网对面的墙，通常AI不需要预测这么远，但写上无妨)
      if (simX < 0) {
          simX = 0;
          simVx = -simVx * 0.8;
      }
      // ==============================

      // 寻找截击点
      if (simX > W/2 + 20 && simX < W - 20) {
          const smashZoneBottom = H * 0.6; 
          const smashZoneTop = H/2 - 100;
          
          if (simY > smashZoneTop && simY < smashZoneBottom) {
              const distToRun = Math.abs(simX - p2.x);
              const timeToRun = distToRun / p2.speed; 
              
              if (timeToRun < timeSteps && bestIntercept === null) {
                  bestIntercept = { x: simX, y: simY };
              }
          }
      }
  }
  landingX = simX;
  
  return { landingX, intercept: bestIntercept };
}

function updateAI(){
  if(gameMode !== 'cpu') return;
  const settings = DIFFICULTY_SETTINGS[selectedDifficulty];
  if (player2.swingAnim > 0) { player2.vx = 0; player2.charging = false; return; }
  
  if(serving === 'player2' && shuttle.stuck){ 
      if (ai.serveDelay > 0) { ai.serveDelay--; if (ai.serveDelay % 40 < 20) player2.x -= 0.5; else player2.x += 0.5; return; }
      if(!player2.charging) { player2.charging = true; player2.chargeVal = 0; const serveType = Math.random(); ai.serveTargetPower = (serveType < 0.3) ? (0.25 + Math.random()*0.1) : (0.85 + Math.random()*0.15); }
      let chargeRate = player2.chargeRate * settings.chargeSpeed; player2.chargeVal = Math.min(1, player2.chargeVal + chargeRate);
      if(player2.chargeVal >= ai.serveTargetPower) { player2.charging = false; player2.swingAnim = 10; serve('player2', player2.chargeVal); player2.chargeVal = 0; resetAI(); }
      return; 
  }
  const ballComing = shuttle.vx > 0;
  if (!ballComing && !shuttle.stuck) { 
      player2.charging = false; player2.chargeVal = 0; ai.predictedX = null; ai.smashIntent = false; 
      if (player2.x < W/2 + 100) { let moveTarget = ai.baseX; if (Math.abs(player2.x - moveTarget) > 10) { player2.vx = (player2.x < moveTarget) ? player2.speed * 0.8 : -player2.speed * 0.8; } else { player2.vx = 0; } } else { player2.vx = 0; }
      return; 
  }
  if (selectedDifficulty === 'hell' && ballComing) { ai.recalcTimer++; if (ai.recalcTimer > 5) { ai.predictedX = null; ai.recalcTimer = 0; } }
  if (ballComing && ai.predictedX === null && shuttle.x > W/2 - 300) {
      const traj = analyzeTrajectory(player2);
      if (traj) {
          let target = traj.landingX; ai.interceptY = null;
          if (settings.intercept && traj.intercept) { target = traj.intercept.x - 10; ai.interceptY = traj.intercept.y; ai.smashIntent = true; } 
          else { ai.smashIntent = false; }
          let maxError = settings.error; ai.errorOffset = (Math.random() - 0.5) * maxError;
          if (target > W - COURT_PADDING + 20) { let intelligence = (selectedDifficulty === 'easy') ? 0.5 : 1.0; if (Math.random() < intelligence) ai.willOut = true; else ai.willOut = false; } 
          else { ai.willOut = false; ai.predictedX = target + ai.errorOffset; }
          ai.reactionTimer = settings.reaction + Math.random() * 5;
      }
  }
  let moveTarget = ai.baseX;
  if (ballComing && ai.predictedX !== null) {
      if (ai.reactionTimer > 0) { ai.reactionTimer--; moveTarget = player2.x; } 
      else if (ai.willOut) { moveTarget = W - 80; } 
      else { let offset = (player2.roleName === '力量型') ? 20 : 0; moveTarget = clamp(ai.predictedX + offset, W/2 + 40, W - 40); }
  }
  let actualSpeed = player2.speed * settings.speedMult;
  let distToTarget = Math.abs(player2.x - moveTarget);
  if (distToTarget > 10) { player2.vx = (player2.x < moveTarget) ? actualSpeed : -actualSpeed; } else { player2.vx = 0; }
  
  if (distToTarget > 60) { player2.charging = false; player2.chargeVal = 0; }

  if (ai.smashIntent && ai.interceptY && player2.onGround && ballComing) { const distX = Math.abs(player2.x - shuttle.x); if (distX < 150 && shuttle.x < player2.x) { player2.vy = -player2.jumpPower; player2.onGround = false; } }
  if (ai.willOut && shuttle.x > W - 100) { player2.charging = false; return; }
  const dx = shuttle.x - player2.handX; const dy = shuttle.y - player2.handY; const dist = Math.hypot(dx, dy);
  if (ballComing && shuttle.x > W/2 && dist < 400 && !player2.charging) { 
      if (distToTarget < 60 || ai.smashIntent) { player2.charging = true; player2.chargeVal = 0; }
  }
  if (player2.charging) { let chargeRate = player2.chargeRate * settings.chargeSpeed; player2.chargeVal = Math.min(1, player2.chargeVal + chargeRate); }
  let hitRange = player2.hitRange + 20;
  if (dist <= hitRange && !shuttle.stuck && shuttle.x > W/2) {
    let isHighEnough = shuttle.y < (H * 0.6); let canSmash = isHighEnough && !player2.onGround;
    player2.charging = false; let power = player2.chargeVal > 0 ? player2.chargeVal : 0.5;
    if (canSmash && ai.smashIntent) power = 1.0; 
    else if (shuttle.y > H - 150) { power = (selectedDifficulty === 'easy') ? 0.6 : 0.95; ai.smashIntent = false; }
    else { if (selectedDifficulty !== 'easy' && player2.roleName === '极速型' && Math.random() < 0.3) power = 0.15; ai.smashIntent = false; }
    triggerSwing(player2, power); player2.chargeVal = 0; ai.smashIntent = false; ai.predictedX = null; ai.interceptY = null;
  }
}

function updateParticles(dt) { for(let i=particles.length-1; i>=0; i--){ let p = particles[i]; p.x += p.vx * dt; p.y += p.vy * dt; p.life -= 0.08 * dt; if(p.life <= 0) particles.splice(i, 1); } }
function createHitParticles(x, y, color, count=12) { for(let i=0; i<count; i++) particles.push({ x: x, y: y, vx: (Math.random()-0.5)*15, vy: (Math.random()-0.5)*15, life: 1.0, color: color }); }

function update(dt){
    
  // AI 自动释放技能 (如果满了就放)
  if (gameMode === 'cpu' && player2.energy >= 100) activateSkill(player2);

  // === 2. 技能状态更新 ===
  [player, player2].forEach(p => {
      if (p.skillActive) {
          p.skillTimer -= dt;
          if (p.skillTimer <= 0) deactivateSkill(p);
      }
  });

  // === 3. 忍者技能特殊效果：时空减速 ===
  // 如果有人开启了忍者技能，计算一个“时间流速系数”
  let timeScale = 1.0;
  if (player.skillActive && player.id === 'ninja') timeScale = 0.5; // P1是忍者开大，P2和球变慢
  if (player2.skillActive && player2.id === 'ninja') timeScale = 0.5;

  // 如果是对方开大，dt 就要乘上 timeScale，让自己变慢
  // 注意：这个逻辑比较绕。简单的做法是：
  // 如果 P1 开了时缓，P2 的 dt 变小。
  
  let dtP1 = dt;
  let dtP2 = dt;
  let dtBall = dt;

  // --- 情况 A: P1 是忍者且开大 ---
  if (player.skillActive && player.id === 'ninja') { 
      dtP2 *= 0.5;    // 对手(P2)动作永远变慢
      
      // 球的时间流速取决于最后是谁打的
      // 如果是 P2 打过来的(incoming)，球变慢 -> 忍者容易接
      // 如果是 P1 打出去的(outgoing)，球保持原速 -> 对手看着很快
      if (lastHitter === 'player2') dtBall *= 0.5;
  }

  // --- 情况 B: P2 是忍者且开大 ---
  if (player2.skillActive && player2.id === 'ninja') { 
      dtP1 *= 0.5;    // 对手(P1)动作永远变慢
      
      // 同理
      if (lastHitter === 'player') dtBall *= 0.5;
  }

  updateAI();

  // === 忍者残影记录逻辑 (修改版) ===
  [player, player2].forEach(p => {
      if (p.id === 'ninja' && p.skillActive) {
          // 这里的判断改为简单的帧率控制，避免 Date.now() 的不确定性
          // 我们给角色加一个临时计数器，如果不存在就初始化
          if (!p.trailCounter) p.trailCounter = 0;
          p.trailCounter++;

          // 每 3 帧记录一次残影
          if (p.trailCounter % 3 === 0) {
              p.trails.push({
                  x: p.x, 
                  y: p.y, 
                  vx: p.vx,
                  onGround: p.onGround,
                  swingAnim: p.swingAnim,
                  charging: p.charging,
                  chargeVal: p.chargeVal,
                  life: 1.0,
                  // === 关键修改：记录当前的跑步周期 ===
                  // 这样画出来就是“那一瞬间”的腿部姿态
                  walkCycle: Date.now() * 0.015 
              });
          }
      }
      
      // 残影生命周期更新
      if (p.trails && p.trails.length > 0) {
          for (let i = p.trails.length - 1; i >= 0; i--) {
              p.trails[i].life -= 0.05; 
              if (p.trails[i].life <= 0) p.trails.splice(i, 1);
          }
      }
  });

  if(player.charging) player.chargeVal = Math.min(1, player.chargeVal + player.chargeRate * dtP1); // 用 dtP1
  if(gameMode === 'pvp' && player2.charging) player2.chargeVal = Math.min(1, player2.chargeVal + player2.chargeRate * dtP2); // 用 dtP2
  
  // === 移动物理逻辑 (叠加击退效果) ===
  
  // --- 第一步：计算水平速度 (vx) ---
  // 包括：基础移动 + 飞行加速 + 击退叠加
  
  // P1 水平逻辑
  let p1BaseSpeed = player.speed;
  if (player.skillActive && player.id === 'speed') p1BaseSpeed *= 1.5; // 飞行模式水平加速
  
  let p1IntentVx = 0;
  if (keys['KeyA']) p1IntentVx = -p1BaseSpeed;
  else if (keys['KeyD']) p1IntentVx = p1BaseSpeed;
  
  player.vx = p1IntentVx + (player.impactVx || 0); // 叠加击退

  // P2 水平逻辑
  let p2BaseSpeed = player2.speed;
  if (player2.skillActive && player2.id === 'speed') p2BaseSpeed *= 1.5;

  let p2IntentVx = 0;
  if (gameMode === 'pvp') {
      if (keys['ArrowLeft']) p2IntentVx = -p2BaseSpeed;
      else if (keys['ArrowRight']) p2IntentVx = p2BaseSpeed;
  } else {
      // CPU 模式：如果是飞行状态，稍微加点速
      p2IntentVx = player2.vx; 
      if (player2.skillActive && player2.id === 'speed') p2IntentVx *= 1.5;
  }
  
  player2.vx = p2IntentVx + (player2.impactVx || 0); // 叠加击退

  // --- 第二步：击退阻尼 (摩擦力) ---
  if (player.impactVx) {
      player.impactVx *= 0.9;
      if(Math.abs(player.impactVx) < 0.5) player.impactVx = 0;
  }
  if (player2.impactVx) {
      player2.impactVx *= 0.9;
      if(Math.abs(player2.impactVx) < 0.5) player2.impactVx = 0;
  }

  // --- 第三步：垂直物理与位置更新 (vy & x/y) ---
  
  // P1 垂直逻辑
  if (player.skillActive && player.id === 'speed') {
      // [飞行模式]
      if (keys['KeyW']) player.vy = -player.speed * 1.2;
      else if (keys['KeyS']) player.vy = player.speed * 1.2;
      else player.vy = 0; 
      player.onGround = false;
      if (Math.random()<0.3) createHitParticles(player.x, player.y+20, '#60a5fa', 1);
  } else {
      // [普通模式]
      player.vy += worldGravity * dtP1 * 0.9;
  }
  // 应用位移 (注意：vx 已经在第一步算好了，这里不要再覆盖！)
  player.x += player.vx * dtP1 * 4;
  player.y += player.vy * dtP1 * 4;


  // P2 垂直逻辑
  if (player2.skillActive && player2.id === 'speed') {
      // [飞行模式]
      if (gameMode === 'pvp') {
          if (keys['ArrowUp']) player2.vy = -player2.speed * 1.2;
          else if (keys['ArrowDown']) player2.vy = player2.speed * 1.2;
          else player2.vy = 0;
      } else {
          // AI 飞行追球
          if (shuttle.y < player2.y - 50) player2.vy = -player2.speed;
          else if (shuttle.y > player2.y + 50) player2.vy = player2.speed;
          else player2.vy = 0;
      }
      player2.onGround = false;
      if (Math.random()<0.3) createHitParticles(player2.x, player2.y+20, '#60a5fa', 1);
  } else {
      // [普通模式]
      player2.vy += worldGravity * dtP2 * 0.9;
  }
  // 应用位移
  player2.x += player2.vx * dtP2 * 4;
  player2.y += player2.vy * dtP2 * 4;


  if(player.y >= H - 40){ player.y = H - 40; player.vy = 0; player.onGround = true; if(player.jumpCount) player.jumpCount=0; }
  if(player2.y >= H - 40){ player2.y = H - 40; player2.vy = 0; player2.onGround = true; if(player2.jumpCount) player2.jumpCount=0; }
  
  // 发球物理界限锁：发球阶段不能越过 200px 线
  const boundL = COURT_PADDING + 20; const boundR = W - COURT_PADDING - 20;
  const serviceLineDist = 200;
  let p1LimitR = W/2 - 50; let p2LimitL = W/2 + 50;
  
  
  if (shuttle.stuck) { 
      p1LimitR = W/2 - serviceLineDist; 
      p2LimitL = W/2 + serviceLineDist; 
  }
  
  player.x = clamp(player.x, boundL, p1LimitR); 
  player2.x = clamp(player2.x, p2LimitL, boundR);

  if(player.swingTimer > 0) player.swingTimer--; if(player2.swingTimer > 0) player2.swingTimer--;
  if(player.swingAnim > 0) player.swingAnim--; if(player2.swingAnim > 0) player2.swingAnim--;

  if(!shuttle.stuck){
    const prevX = shuttle.x;
    // 更新球物理 (用 dtBall -> 球速变慢)
    shuttle.vy += worldGravity * dtBall * 0.8; 
    // 空气阻力也要受时间流速影响
    let drag = Math.pow(airDrag, dtBall); 
    shuttle.vx *= drag; 
    shuttle.vy *= drag;
    
    shuttle.x += shuttle.vx * dtBall; 
    shuttle.y += shuttle.vy * dtBall;

    const bounceDamping = 0.75; // 反弹力度损耗 (0.75 表示保留 75% 的速度)

    // 1. 天花板反弹
    if (shuttle.y < 0) {
        shuttle.y = 0;
        shuttle.vy = Math.abs(shuttle.vy) * bounceDamping; // 强制向下
        beep(150, 0.05, 'square'); // 撞墙音效
        createHitParticles(shuttle.x, 0, '#aaaaaa', 8); // 撞墙灰尘特效
    }

    // 2. 左墙反弹
    if (shuttle.x < 0) {
        shuttle.x = 0;
        shuttle.vx = Math.abs(shuttle.vx) * bounceDamping; // 强制向右
        beep(150, 0.05, 'square');
        createHitParticles(0, shuttle.y, '#aaaaaa', 8);
    }

    // 3. 右墙反弹
    if (shuttle.x > W) {
        shuttle.x = W;
        shuttle.vx = -Math.abs(shuttle.vx) * bounceDamping; // 强制向左
        beep(150, 0.05, 'square');
        createHitParticles(W, shuttle.y, '#aaaaaa', 8);
    }

    const netX = W/2; const netTop = H * 0.75; 
    if (Math.abs(shuttle.x - netX) < 10 && shuttle.y > netTop) {
        if (shuttle.y < netTop + 15) { shuttle.vy = -Math.abs(shuttle.vy)*0.7-2; shuttle.vx*=-0.5; shuttle.x = (shuttle.x<netX)?netX-12:netX+12; beep(200,0.05,'triangle',0.15); } 
        else { shuttle.vx *= -0.2; if(prevX<netX && shuttle.x>netX) shuttle.x=netX-8; if(prevX>netX && shuttle.x<netX) shuttle.x=netX+8; }
    }
    
    // === 修改：落地判定 (取消出界，只判死活) ===
    if(shuttle.y > H - 10){
      // 不再判断 inLeft/inRight，只要落地就算分
      if (shuttle.x < W / 2) {
          // 落在左边 (P1半场)，P2 得分
          pointScored('player2', "P2 得分!"); 
      } else {
          // 落在右边 (P2半场)，P1 得分
          pointScored('player', "P1 得分!"); 
      }
      return; 
    }
    
      // Player 1 击球逻辑
    if(collideRacket(player) && player.swingTimer > 0 && !player.hasHit) {
        // 只有当最后击球的人不是我（是对方或刚开局）时，才能击球
        if (lastHitter !== 'player') {
            handleHit(player, 1);
        }
    }

    // Player 2 击球逻辑
    if(collideRacket(player2) && player2.swingTimer > 0 && !player2.hasHit) {
        // 同理，只有最后击球的人不是 P2 时，P2 才能击球
        if (lastHitter !== 'player2') {
            handleHit(player2, -1);
        }
    }
    
    } else { recalcPositions(); }
    updateParticles(dt);


      // === 新增：同步 HTML 能量条 ===
    const p1Bar = document.getElementById('p1EBar');
    const p2Bar = document.getElementById('p2EBar');
    
    p1Bar.style.width = player.energy + '%';
    p2Bar.style.width = player2.energy + '%';
    
    // 能量满时添加发光动画 class
    if(player.energy >= 100) p1Bar.parentElement.classList.add('energy-full');
    else p1Bar.parentElement.classList.remove('energy-full');
    
    if(player2.energy >= 100) p2Bar.parentElement.classList.add('energy-full');
    else p2Bar.parentElement.classList.remove('energy-full');
}

function handleHit(pObj, dir) {
  // 在击球处理开始前，先检查是不是接到了“陨石球”
  // 如果球是陨石状态，且当前击球者不是刚才打出陨石的人（防止自己连击触发击退）
  if (shuttle.isMeteor && lastHitter !== (pObj === player ? 'player' : 'player2')) {
      // === 触发击退效果 ===
      beep(100, 0.3, 'sawtooth'); // 沉重的撞击声
      
      // 1. 施加巨大的反向速度 (向后飞)
      // dir是击球方向(1向右, -1向左)，所以 -dir 就是向后
      pObj.impactVx = -dir * 7;
      
      // 3. 产生火花特效
      createHitParticles(pObj.x, pObj.y, '#ff4400', 30);
      
      // 4. 球的陨石状态解除 (动能被吸收了)
      shuttle.isMeteor = false;
  }
  
  lastHitter = (dir === 1) ? 'player' : 'player2';
    if (!pObj.skillActive) {
      pObj.energy = Math.min(pObj.maxEnergy, pObj.energy + 20);
    }
  pObj.hasHit = true; 
  let power = pObj.lastPower || 0.5; pObj.charging = false; pObj.chargeVal = 0;
  const isJumpSmash = !pObj.onGround && shuttle.y < (H * 0.6);
  const isDropShot = power < 0.4 && !isJumpSmash;
  const powerFactor = pObj.maxPower || 1.0; 
  if(isJumpSmash) {
    shuttle.isSmash = true;
    // 修复：任何角色扣杀都显示提示

    // === 巨人制造陨石 ===
    if (pObj.isGiant) {
        shuttle.isMeteor = true; // 标记为陨石
    } else {
        shuttle.isMeteor = false;
    }

    if(pObj === player) showMsg("P1 扣杀!!"); 
    else showMsg("P2 扣杀!!");
    
    const distToNet = Math.abs(pObj.x - W/2);
    let smashSpeed = Math.abs(baseSpeed + level) * (1.9 + power * 1.3) * pObj.smashMult * powerFactor;
    if (distToNet > 250) smashSpeed *= (1 + (distToNet - 250) / 400); 
    let netProximity = Math.max(0.2, 1 - (distToNet / 400));
    let desiredVy = 8 + (netProximity * 18) + (power * 5);
    const netSafeHeight = H * 0.75 - 20;
    let avgVx = smashSpeed * 0.95; let timeToNet = distToNet / avgVx;
    let maxVyAllowed = (netSafeHeight - shuttle.y) / timeToNet - (0.5 * worldGravity * timeToNet);
    if (desiredVy > maxVyAllowed) {
        desiredVy = maxVyAllowed; 
        if (desiredVy < 2) { desiredVy = 2; smashSpeed *= 1.2; }
    }
    shuttle.vx = dir * smashSpeed; shuttle.vy = desiredVy; 
    playSmashSound(power); createHitParticles(shuttle.x, shuttle.y, pObj.color, 25); 
  } else {
    // 普通击球会取消陨石状态
    shuttle.isSmash = false;
    shuttle.isMeteor = false; 
    if (isDropShot) {
       shuttle.vx = dir * Math.abs(baseSpeed) * (1.0 + power); shuttle.vy = -7 - Math.random()*2; 
       beep(800, 0.05, 'triangle', 0.1); createHitParticles(shuttle.x, shuttle.y, '#ffffff', 5);
    } else {
       let hitSpeed = Math.abs(baseSpeed + level) * (1.3 + power * 0.8) * (1 + (pObj.smashMult-1)*0.5) * powerFactor;
       let upForce = -8 - (power * 8); 
       shuttle.vx = dir * hitSpeed; shuttle.vy = upForce; 
       beep(600, 0.1, 'sine', 0.1 + power*0.1); createHitParticles(shuttle.x, shuttle.y, pObj.color, 10);
    }
  }
}
  

function loop(t){ if(!running) return; const now = t || performance.now(); let dt = (now - lastTime) / 16.666; if(!isFinite(dt) || dt <= 0) dt = 1; if(dt > 4) dt = 4; lastTime = now; if(!paused && !gameOver){ update(dt); draw(); } requestAnimationFrame(loop); }

function draw(){ ctx.clearRect(0,0,W,H); drawCourt(); drawNet(); drawParticles(); drawShuttle(); drawStickman(player,true); drawStickman(player2,false); }
function drawCourt(){ const grd = ctx.createLinearGradient(0,0,0,H); grd.addColorStop(0,'rgba(255,255,255,0.02)'); grd.addColorStop(1,'rgba(0,0,0,0.12)'); ctx.fillStyle = grd; ctx.fillRect(0,0,W,H); ctx.fillStyle = '#0b1220'; ctx.fillRect(0, H-10, W, 10); ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(COURT_PADDING, H-10); ctx.lineTo(COURT_PADDING, H-40); ctx.moveTo(W - COURT_PADDING, H-10); ctx.lineTo(W - COURT_PADDING, H-40); ctx.stroke(); ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.beginPath(); ctx.moveTo(COURT_PADDING, H-10); ctx.lineTo(W-COURT_PADDING, H-10); ctx.stroke(); 
// 绘制发球线 (200px处)
ctx.strokeStyle = 'rgba(255,255,255,0.15)'; ctx.setLineDash([5, 5]); 
ctx.beginPath(); ctx.moveTo(W/2 - 200, H-10); ctx.lineTo(W/2 - 200, H-40); ctx.stroke();
ctx.beginPath(); ctx.moveTo(W/2 + 200, H-10); ctx.lineTo(W/2 + 200, H-40); ctx.stroke();
ctx.setLineDash([]);
}
function drawNet(){ const netTop = H*0.75; ctx.fillStyle='rgba(255,255,255,0.1)'; ctx.fillRect(W/2-4,netTop,8,H-netTop); }
function drawParticles() { for(let p of particles){ ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI*2); ctx.fill(); } ctx.globalAlpha = 1; }
function drawShuttle() {
    // 1. 高空指示器 (保持不变)
    if (shuttle.y < -20) {
        ctx.save(); ctx.fillStyle = shuttle.isSmash ? '#ff4444' : '#fff'; ctx.beginPath();
        ctx.moveTo(shuttle.x, 15); ctx.lineTo(shuttle.x - 8, 25); ctx.lineTo(shuttle.x + 8, 25); ctx.fill(); ctx.restore();
        return; 
    }

    ctx.save(); 
    ctx.translate(shuttle.x, shuttle.y); 
    
    // 计算旋转角度
    let angle = 0; 
    if (shuttle.stuck) { 
        if (serving === 'player') angle = -0.5; else angle = Math.PI + 0.5; 
    } else { 
        if (Math.abs(shuttle.vx) > 0.1 || Math.abs(shuttle.vy) > 0.1) angle = Math.atan2(shuttle.vy, shuttle.vx); 
    } 
    ctx.rotate(angle); 

    // === 2. 陨石特效 (大幅增强版) ===
    if (shuttle.isMeteor) {
        // A. 绘制核心光晕 (巨大的燃烧气场)
        const gradient = ctx.createRadialGradient(0, 0, 5, 0, 0, 40);
        gradient.addColorStop(0, 'rgba(255, 255, 0, 0.9)');   // 中心极亮黄
        gradient.addColorStop(0.3, 'rgba(255, 69, 0, 0.6)');  // 中层橙红
        gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');       // 边缘透明
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(0, 0, 45, 0, Math.PI*2);
        ctx.fill();

        // B. 绘制湍流尾焰 (向后方 -x 方向延伸)
        for(let i=0; i<20; i++) { // 粒子数量加倍
            ctx.beginPath();
            // 随机颜色：黄色 或 橙红
            ctx.fillStyle = Math.random() > 0.4 ? '#ffff00' : '#ff4500';
            
            // 透明度随距离衰减
            ctx.globalAlpha = (1 - i/20) * 0.8;

            // 坐标计算：
            // X: 向后延伸，并在一定范围内随机抖动
            const trailX = -10 - (i * 6) - Math.random() * 10;
            // Y: 越往后，扩散范围(spread)越大，模拟火焰扩散
            const spread = 5 + i * 1.5;
            const trailY = (Math.random() - 0.5) * spread;

            // 大小：越往后越小
            const size = 12 - (i * 0.5);
            
            ctx.arc(trailX, trailY, size > 0 ? size : 1, 0, Math.PI*2);
            ctx.fill();
        }
        ctx.globalAlpha = 1.0; // 恢复透明度
    }
    // ===============================

    // 3. 绘制羽毛球本体 (在火焰之上)
    const skirtLen = 22; const skirtWidth = 14; const neckWidth = 6; 
    ctx.beginPath(); ctx.moveTo(-4, -neckWidth); ctx.lineTo(-skirtLen, -skirtWidth); ctx.lineTo(-skirtLen, skirtWidth); ctx.lineTo(-4, neckWidth); ctx.closePath(); 
    
    // 如果是陨石状态，羽毛变成暗红色，否则正常
    ctx.fillStyle = shuttle.isMeteor ? '#550000' : (shuttle.isSmash ? '#ffcccc' : '#ffffff'); 
    ctx.fill(); 
    
    ctx.strokeStyle = '#e2e8f0'; ctx.lineWidth = 1; ctx.beginPath(); 
    ctx.moveTo(-4, 0); ctx.lineTo(-skirtLen, 0); ctx.moveTo(-8, -neckWidth-1); ctx.lineTo(-8, neckWidth+1); ctx.moveTo(-15, -skirtWidth+2); ctx.lineTo(-15, skirtWidth-2); ctx.stroke(); 
    
    // 球头
    ctx.beginPath(); ctx.arc(0, 0, 7, 0, Math.PI * 2); 
    // 陨石状态球头变成黑炭色
    const corkColor = shuttle.isMeteor ? '#000' : (shuttle.isSmash ? '#ef4444' : '#1e293b'); 
    const grd = ctx.createRadialGradient(-2, -2, 1, 0, 0, 7); grd.addColorStop(0, '#64748b'); grd.addColorStop(0.3, corkColor); grd.addColorStop(1, corkColor); 
    ctx.fillStyle = grd; ctx.fill(); 
    if(!shuttle.isSmash) { ctx.strokeStyle = '#0f1724'; ctx.lineWidth = 1; ctx.stroke(); } 
    
    // 速度线 (仅非陨石状态显示，陨石有火焰了不需要线)
    if (!shuttle.stuck && !shuttle.isMeteor && (Math.abs(shuttle.vx) > 10 || Math.abs(shuttle.vy) > 10)) { 
        ctx.beginPath(); ctx.strokeStyle = shuttle.isSmash ? 'rgba(239, 68, 68, 0.6)' : 'rgba(255, 255, 255, 0.4)'; ctx.lineWidth = 2; 
        for(let i=0; i<3; i++) { const yOffset = (i-1) * 6; ctx.moveTo(-skirtLen - 5, yOffset); ctx.lineTo(-skirtLen - 15 - Math.random()*10, yOffset); } 
        ctx.stroke(); 
    } 
    ctx.restore(); 
}

function drawStickman(d, isPlayer, isGhost = false) {
    
    // 1. 【忍者】奥义残影绘制 (放在最前面)
    if (d.trails && d.trails.length > 0) {
        d.trails.forEach((t) => {
            ctx.save();
            ctx.globalAlpha = t.life * 0.5; 
            const facingDir = isPlayer ? 1 : -1;
            const tColor = d.color;
            
            // 残影头
            ctx.fillStyle = tColor; ctx.beginPath(); 
            ctx.arc(t.x, t.y - 98, 12, 0, Math.PI*2); ctx.fill();
            
            // 残影身体
            ctx.strokeStyle = tColor; ctx.lineWidth = 3; ctx.lineCap = 'round';
            ctx.beginPath(); ctx.moveTo(t.x, t.y - 86); ctx.lineTo(t.x, t.y - 30); ctx.stroke();

            // 残影腿部
            let lFootX, lFootY, rFootX, rFootY;
            const groundY = t.y;
            if (!t.onGround) {
                lFootX = t.x - 10 * facingDir; lFootY = groundY - 10;
                rFootX = t.x + 12 * facingDir; rFootY = groundY - 5;
            } else if (Math.abs(t.vx) > 0.5) {
                const stride = 18; 
                lFootX = t.x + Math.sin(t.walkCycle) * stride; lFootY = groundY;
                rFootX = t.x + Math.sin(t.walkCycle + Math.PI) * stride; rFootY = groundY;
            } else {
                lFootX = t.x - 10; lFootY = groundY; rFootX = t.x + 10; rFootY = groundY;
            }
            ctx.beginPath(); ctx.moveTo(t.x, t.y - 30); ctx.lineTo(lFootX, lFootY); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(t.x, t.y - 30); ctx.lineTo(rFootX, rFootY); ctx.stroke();

            // 残影手臂
            let shoulderY = t.y - 75;
            let handX = t.x + (25 * facingDir); let handY = shoulderY + 20;
            if (t.charging || t.swingAnim > 0) { handX = t.x - (20 * facingDir); handY = shoulderY - 30; }
            ctx.beginPath(); ctx.moveTo(t.x, shoulderY); ctx.lineTo(handX, handY); ctx.stroke();

            ctx.restore();
        });
    }
    
    // === 2. 绘制本体 ===
    ctx.save(); 
    
    // === 巨人化绘制逻辑 ===
    if (d.isGiant && !isGhost) {
        // 1. 坐标变换：以脚底为中心放大
        ctx.translate(d.x, d.y); // 移到脚底
        ctx.scale(1.5, 1.5);     // 放大 1.5 倍
        ctx.translate(-d.x, -d.y); // 移回去
        
        // 2. 蒸汽特效 (二档模式)
        if (Math.random() < 0.5) {
            // 在身体周围随机产生向上飘的红烟
            createHitParticles(
                d.x + (Math.random()-0.5)*30, 
                d.y - Math.random()*80, 
                'rgba(255, 50, 0, 0.5)', 1
            );
        }
    }

    // --- 关键：必须先定义这些坐标变量，特效代码才能使用 ---
    const cx = d.x; 
    const headR = 12; 
    const bodyBottom = d.y - 30; 
    const bodyTop = d.y - 80; 
    const groundY = d.y; 
    const color = d.color; 
    const facingDir = isPlayer ? 1 : -1; 
    // --------------------------------------------------

    // 【极速型】特效：机甲光刃
    if (d.skillActive && d.id === 'speed' && !isGhost) {
        ctx.save();
        ctx.translate(cx, bodyTop + 20); // 背部中心
        
        // 呼吸效果：光翼大小随时间轻微缩放
        const breath = 1 + Math.sin(Date.now() * 0.01) * 0.1;
        ctx.scale(breath, breath);

        ctx.shadowBlur = 20;
        ctx.shadowColor = '#00ffff';
        ctx.fillStyle = 'rgba(100, 255, 255, 0.6)'; // 半透明核心
        ctx.strokeStyle = '#fff'; // 亮白边缘
        ctx.lineWidth = 2;

        // 绘制左侧三片光刃
        for (let i = 0; i < 3; i++) {
            ctx.save();
            ctx.rotate((i * 0.3) - 0.5); // 扇形张开角度
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-60 - (i * 10), -10); // 翼尖
            ctx.lineTo(-40, 5); // 翼根
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        }

        // 绘制右侧三片光刃 (镜像)
        for (let i = 0; i < 3; i++) {
            ctx.save();
            ctx.rotate(-(i * 0.3) + 0.5); 
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(60 + (i * 10), -10);
            ctx.lineTo(40, 5);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        }
        
        ctx.restore();
    } 

    // 【均衡型】金光特效
    if (d.skillActive && d.id === 'balanced' && !isGhost) {
        ctx.save(); ctx.translate(d.x, d.y - 40);
        const scale = 1 + Math.sin(Date.now() * 0.02) * 0.1;
        ctx.scale(scale, scale);
        ctx.fillStyle = 'rgba(255, 215, 0, 0.3)'; ctx.beginPath(); ctx.arc(0, 0, 50, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = 'rgba(255, 255, 0, 0.6)'; ctx.lineWidth = 2;
        for(let i=0; i<3; i++) {
            let offset = (Date.now() / 10 + i * 50) % 60;
            ctx.beginPath(); ctx.moveTo(-20 + i*20, 40 - offset); ctx.lineTo(-20 + i*20, 20 - offset); ctx.stroke();
        }
        ctx.restore();
        ctx.fillStyle = '#fffacd'; ctx.strokeStyle = '#fffacd';
    } else {
        ctx.fillStyle = color; ctx.strokeStyle = color;
    }

    // 绘制头
    ctx.beginPath(); ctx.arc(cx, bodyTop - 18, headR, 0, Math.PI*2); ctx.fill(); 
    // 绘制躯干
    ctx.lineWidth = 4; ctx.lineCap = 'round'; 
    ctx.beginPath(); ctx.moveTo(cx, bodyTop - 6); ctx.lineTo(cx, bodyBottom); ctx.stroke(); 

    // 绘制腿部
    let lFootX, lFootY, rFootX, rFootY; 
    if (!d.onGround) { lFootX = cx - 10 * facingDir; lFootY = groundY - 10; rFootX = cx + 12 * facingDir; rFootY = groundY - 5; } 
    else if (Math.abs(d.vx) > 0.5) { const walkCycle = Date.now() * 0.015; const stride = 18; lFootX = cx + Math.sin(walkCycle) * stride; lFootY = groundY; rFootX = cx + Math.sin(walkCycle + Math.PI) * stride; rFootY = groundY; } 
    else { lFootX = cx - 10; lFootY = groundY; rFootX = cx + 10; rFootY = groundY; } 
    function drawLeg(hx, hy, fx, fy) { ctx.beginPath(); ctx.moveTo(hx, hy); const midX = (hx + fx) / 2; const midY = (hy + fy) / 2; const kneeX = midX + (facingDir * 4); const kneeY = midY; ctx.lineTo(kneeX, kneeY); ctx.lineTo(fx, fy); ctx.stroke(); } 
    drawLeg(cx, bodyBottom, lFootX, lFootY); drawLeg(cx, bodyBottom, rFootX, rFootY); 

    // 绘制手臂与球拍
    const shoulderY = bodyTop + 5; let upperArmLen = 22; let lowerArmLen = 22; let shoulderX = cx; let targetHandX, targetHandY; let baseHandX = cx + (isPlayer?25:-25); let baseHandY = shoulderY + 20; if(d.charging) { let pullBack = 20 + d.chargeVal * 20; let liftUp = 30 + d.chargeVal * 20; targetHandX = cx - (isPlayer ? pullBack : -pullBack); targetHandY = shoulderY - liftUp; } else if (d.swingAnim > 0) { let t = 1 - (d.swingAnim / 10); let startX = cx - (isPlayer ? 30 : -30); let startY = shoulderY - 40; let endX = cx + (isPlayer ? 40 : -40); let endY = shoulderY + 30; if(shuttle.isSmash) endY += 20; targetHandX = startX + (endX - startX) * t; targetHandY = startY + (endY - startY) * t; targetHandY -= Math.sin(t * Math.PI) * 10; } else { targetHandX = baseHandX; targetHandY = baseHandY; } let dx = targetHandX - shoulderX; let dy = targetHandY - shoulderY; let dist = Math.hypot(dx, dy); if(dist > (upperArmLen + lowerArmLen)) { let scale = (upperArmLen + lowerArmLen) / dist; targetHandX = shoulderX + dx * scale; targetHandY = shoulderY + dy * scale; } let midX = (shoulderX + targetHandX) / 2; let midY = (shoulderY + targetHandY) / 2; let elbowDir = (isPlayer ? -1 : 1); let elbowX = midX + elbowDir * 10; let elbowY = midY + 10; ctx.beginPath(); ctx.moveTo(shoulderX, shoulderY); ctx.lineTo(elbowX, elbowY); ctx.lineTo(targetHandX, targetHandY); ctx.stroke(); d.handX = targetHandX; d.handY = targetHandY; let armAngle = Math.atan2(targetHandY - elbowY, targetHandX - elbowX); ctx.save(); ctx.translate(targetHandX, targetHandY); ctx.rotate(armAngle); ctx.strokeStyle = '#888'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(15, 0); ctx.stroke(); ctx.translate(15, 0); ctx.rotate(d.charging ? -0.5 : 0); ctx.strokeStyle = '#eee'; ctx.lineWidth = 2; ctx.beginPath(); ctx.ellipse(10, 0, 12, 8, 0, 0, Math.PI*2); ctx.stroke(); if(d.swingAnim > 0) { ctx.fillStyle = shuttle.isSmash ? 'rgba(255,0,0,0.3)' : 'rgba(255,255,255,0.2)'; ctx.beginPath(); ctx.arc(0,0, 20, 0, Math.PI*2); ctx.fill(); } ctx.restore(); ctx.restore(); 

    // 蓄力条 (Keep this)
    if(d.charging) {
        const cBarX = cx - 20; const cBarY = bodyTop - 40;
        ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.fillRect(cBarX, cBarY, 40, 6);
        let pColor = '#00ff00'; if(d.chargeVal > 0.4) pColor = '#ffff00'; if(d.chargeVal > 0.8) pColor = '#ff0000'; 
        ctx.fillStyle = pColor; ctx.fillRect(cBarX, cBarY, 40 * d.chargeVal, 6);
    }
}

</script>
</body>
</html>